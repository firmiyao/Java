<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [创建内部类：](#%E5%88%9B%E5%BB%BA%E5%86%85%E9%83%A8%E7%B1%BB)
- [到外部类的链接：](#%E5%88%B0%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E9%93%BE%E6%8E%A5)
- [使用 .this 和 .new :](#%E4%BD%BF%E7%94%A8-this-%E5%92%8C-new-)
- [在方法和作用域中的内部类：](#%E5%9C%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB)
  - [局部内部类：](#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB)
- [匿名内部类：](#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

**内部类：定义在另一个类中的类称为内部类**

# 创建内部类：

创建内部类的方式就是把类定义放在一个包围它的类之中：

```java
public class Demo {
    //创建内部类：
    class Inner{
        int value;
        Inner(int value){
            this.value=value;
        }
    }

    public Inner get_Inner(int value){
        return new Inner(value);
    }
    public static void main(String[]args) {
      Demo demo=new Demo();
      Demo.Inner test=demo.get_Inner(3);
      System.out.println(test.value);
    }
}
//3
```

上述的Inner就是一个内部类。

# 到外部类的链接：

**当创建一个内部类时，这个内部类的对象中会隐含一个链接，指向用于创建该对象的外围对象。**

```java
interface selector{
    boolean end();
    Object current();
    void next();
}

public class Array {
    private Object[] items;
    private int next=0;
    public Array(int n){
        items=new Object[n];
    }
    public void add(Object t)
    {
        if(next<items.length)
            items[next++]=t;
    }
    //创建内部类：
    private class Array_selector implements selector{
        private int i=0;
        @Override public boolean end(){
            return i==items.length;
        }
        @Override public Object current(){
            return items[i];
        }
        @Override public void next(){
            if(i< items.length)
                i++;
        }
    }
    public Array_selector get_selector()
    {
        return new Array_selector();
    }
    public static void main(String[]args) {
        Array a=new Array(10);
        for(int i=0;i<10;i++){
            a.add(Integer.toString(i));
        }
        Array_selector selector = a.get_selector();
        while(!selector.end())
        {
            System.out.print(selector.current()+" ");
            selector.next();
        }
    }
}
```

结果如下：

![image-20230423212425760](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202304232124790.png)

这就是数组和迭代器，可以发现：**内部类Array_selector的对象可以访问外部对象的方法和字段，就比如它访问了items数组一样，非常方便。**



# 使用 .this 和 .new :

**要生成外部类对象的引用，可以使用外部类的名字，后面加上点和this。**

```java
public class Outer {
    class Inner{
        Outer get_outer()
        {
            return Outer.this;  //返回外部类对象
        }
        Inner get_inner()
        { return this;}    //返回内部类对象
    }
    Inner get_inner_instance(){return new Inner();}
    public static void main(String[]args) {
        Outer outer=new Outer();
        Inner inner = outer.get_inner_instance();
        System.out.println(outer);
        System.out.println(inner.get_outer());
        System.out.println(inner);
        System.out.println(inner.get_inner());
    }
}
```

![image-20230423213749674](https://cdn.jsdelivr.net/gh/firmiyao/Picture/img/202304232137703.png)

**有时我们想让其他某个对象来创建它的某个内部类的对象。要实现这样的功能，可以使用 .new 语法**，如下：

```java
public class Demo {
    //创建内部类：
    class Inner{
        int value;
        Inner(int value){
            this.value=value;
        }
    }

    public Inner get_Inner(int value){
        return new Inner(value);
    }
    public static void main(String[]args) {
        Demo demo=new Demo();
        Demo.Inner test = demo.new Inner(3);
        System.out.println(test.value);
    }
}
//3
```

**除非已经有了一个外部类的对象，否则创建内部类对象是不可能的。然而，如果你使用嵌套类（static修饰的内部类），它就不需要指向外部类的对象的引用。**



# 在方法和作用域中的内部类：

**内部类可以在一个方法内或者任何一个作用域内创建。这么做有两个理由：**

+ 你要实现某种接口，以便创建和返回一个引用；
+ 你要解决一个复杂的问题，在自己的解决方案中创建了一个类来辅助，但是不想让它公开。



## 局部内部类：

**在一个方法的作用域内（而不是在另一个类的作用域内）创建一个完整的类，叫做局部内部类**

```java
interface Destination{
    String read();
}
public class Demo {
    Destination get_destination(String where)  //这是一个方法
    {
        class Inner_destination implements Destination{
            String goal;
            Inner_destination(String where){goal=where;}
            @Override public String read(){
                return goal;
            }
        }
        return new Inner_destination(where);
    }
    public static void main(String[]args) {
        Demo demo=new Demo();
        System.out.println("go to "+demo.get_destination("南昌").read());
    }
}
//go to 南昌
//Inner_destination 的作用域算是全局的，因为接口Destina就是全局的。
```

这就是局部类方法，**这里的接口好似也变成了类**。

总而言之，**可以在任何作用域内嵌入一个内部类**



# 匿名内部类：

以上面的例子为例：

```java
interface Destination{
    String read();
}
class t_class implements Destination{
    String goal;
    t_class(String where){goal=where;}
    @Override public String read(){
        return goal;
    }
}
public class Demo {
    public static void main(String[]args) {
        t_class t=new t_class("南昌");
        System.out.println("go to "+t.read());
    }
}
```

这是常规情况，有一个接口，若要实现它就得创建一个新的类去实现它，这样未免有些麻烦，所以有了匿名内部类：

```java
interface Destination{
    String read();
}
public class Demo {
    Destination get_destination(final String where){
        return new Destination() {
            String goal =where;
            @Override public String read(){
                return goal;
            }
        };   //不能忘记此处的分号
    }
    public static void main(String[]args) {
        Demo demo=new Demo();
        System.out.println("go to "+ demo.get_destination("南昌").read());
    }
}
```

**此处，并没有创建新的类就实现了接口，而接口好似也变成了一个新类**

**如果你正在定义一个匿名类，而且一定要用到一个该匿名类之外定义的对象，编译器要求参数引用用final修饰（?)**