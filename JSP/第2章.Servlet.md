# 什么是servlet？

**servlet = server + applet，意为服务器端的小程序**

**servlet是一种 Java class**，它运行在Java EE的web容器内，**当Web容器接收到对他的request时，自动创建Servlet对象，并自动调用它的相应方法。本质上是一个Java定义的一个类。**



## 类图：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190939095.jpg" alt="3b0ddf3b360cff4ea4102b721e479a0" style="zoom: 33%;" />

Java提供了Servlet接口，在此基础上通过GenericServlet类实现，而HttpServlet类继承了GenericServlet类。



### 实例：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940800.png" alt="image-20231128092117104" style="zoom:50%;" />

所有app项目都要创建在webaaps下面，现在新建demo项目。

创建一个简单html文件：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940780.png" alt="image-20231128092437252" style="zoom:50%;" />

**此时，启动本地Tomcat服务器，在浏览器端输入：**

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940919.png" alt="image-20231128092821034" style="zoom:50%;" />

其中：

+ 127.0.0.1：表示本机IP地址
+ 8080：表示端口
+ **可见开启服务器后，会直接定位到webapps目录下，随后我们进入了demo项目，选择访问hello.html文件**



#### 配置WEB-INF:

之后，**在demo项目下面创建，WEB-INF文件夹，顾名思义，WEB-INF表示web的信息，在它的下面创建：**

+ **classes文件夹：项目运行后，会生成许多.class字节码，全部存储在其中**
+ **lib文件夹：存放该项目运用到的依赖库**
+ **web.xml：web.xml是Java Web应用程序的配置文件，用于配置和定义Web应用程序的各种组件、行为和属性。**



#### 实现Servlet接口：

**在classes可以存放Java源代码和class字节码**，在其中创建Hello.java文件。

```java
package com.servlet;

import javax.servlet.*;
import java.io.IOException;
//实现接口
public class Hello implements Servlet{

    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        
    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
			//提供服务，Servlet主要服务写在此方法中
        System.out.println("Service");
    }

    @Override
    public String getServletInfo() {
        return null;
    }

    @Override
    public void destroy() {

    }
}
```

之后运行：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940130.png" alt="image-20231128095237270" style="zoom:50%;" />

+ **javac：表示进行编译**
+ **-d：表示字节码存放指定位置**
+ **.：表示当前文件夹**
+ **hello.java：表示编译目标**

编译成功：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940360.png" alt="image-20231128095911354" style="zoom:67%;" />

#### 配置web.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
  version="4.0"
  metadata-complete="true">

  <display-name>Welcome to Tomcat</display-name>
  <description>
     Welcome to Tomcat
  </description>

	<servlet>
		<servlet-name>h</servlet-name>   <!-- 名字随便取 -->
		<servlet-class>com.servlet.Hello</servlet-class>   <!-- 包名+类名 -->
	</servlet>
	
	<servlet-mapping>
		<servlet-name>h</servlet-name> <!-- 与上面的servlet-name 一样 -->
		<url-pattern>/a</url-pattern>   <!-- 随便取，但是"/"不能少 -->
	</servlet-mapping>

</web-app>

```

+ `<servlet>`元素用于配置Servlet
   其中：
   + **`servlet-name`是为Servlet指定一个唯一的名称，用于在其他配置元素中引用该Servlet。它是一个字符串值，可以自定义，但必须是唯一的。在同一个web.xml文件中，不同的Servlet需要有不同的名称。**
   + **`servlet-class`指定了Servlet的类名，即实现Servlet接口的Java类。它是一个字符串值，需要指定完整的类名，包括包名。例如：`com.example.MyServlet`。当Web容器启动时，会根据这个类名来实例化和加载相应的Servlet类。**

+ **`<servlet-mapping>`元素用于将Servlet映射到URL模式（URL pattern），以指定哪些URL请求应该由哪个Servlet处理。`<servlet-mapping>`元素与`servlet-name`和`<servlet>`元素中的`servlet-name`属性相关联。**

   **其中：**

   + **`servlet-name`属性：`<servlet-name>`定义了Servlet的名称，必须与`<servlet>`元素中的`servlet-name`保持一致。它用于标识Servlet，并在其他配置元素中引用Servlet。**
   + **`<servlet-mapping>`元素：`<servlet-mapping>`用于指定Servlet的映射关系，即将Servlet映射到URL模式。它包含一个或多个`<url-pattern>`元素，每个`<url-pattern>`定义了一个URL模式。**
   + **映射关系：通过将`servlet-name`和`<url-pattern>`进行匹配，建立Servlet与URL模式之间的映射关系。当用户请求一个URL时，Web容器会根据这些映射关系，找到对应的Servlet来处理该请求。**



#### 运行

此时开启Tomcat服务器，并在浏览器访问

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940850.png" alt="image-20231128133311307" style="zoom:50%;" />

注意取名规则：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940963.png" alt="image-20231128133705134" style="zoom: 50%;" />



#### 浏览器运行：

上面的运行是在本地运行，接下来要实现响应，即服务器**respond**浏览器，只需要更改`service`方法。

```java
@Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        //提供服务，Servlet主要服务写在此方法中
        //System.out.println("Service");
        PrintWriter out = servletResponse.getWriter();
        out.println("hello web!");
    }
```

浏览器查看：

![image-20231128134722967](https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940611.png)

**在response中，我们只需要编辑响应体，不需要编辑响应头。**



#### 默认构造函数的调用

添加默认构造函数，对init()和service()进行修改：

```java
package com.servlet;

import javax.servlet.*;
import java.io.IOException;
import java.io.PrintWriter;

//实现接口
public class Hello implements Servlet{

    //默认构造函数
    public Hello(){
        System.out.println("create()");
    }

    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        System.out.println("init()");
    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        //提供服务，Servlet主要服务写在此方法中
        //System.out.println("Service");
        System.out.println("Service begin");
        PrintWriter out = servletResponse.getWriter();
        out.println("hello web!");
    }

    @Override
    public String getServletInfo() {
        return null;
    }

    @Override
    public void destroy() {

    }
}
```

运行服务器，在浏览器进行访问，并且**刷新进行二次访问**，控制台结果如下：

![image-20231128193939807](https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940361.png)

可知，**在对服务器进行访问时，服务器会自动调用Servlet的默认构造函数，然后调用init()函数，这两个函数只调用一次，因为第一次调用后虚拟机中存在Servlet的字节码，所以不用再创造对象，而每次访问服务器，都会调用service函数**



如果要**在服务器开启时创建Servlet对象**，只需对web.xml文件进行修改：

```xml
<servlet>
        <servlet-name>h</servlet-name>   <!-- 名字随便取 -->
        <servlet-class>com.servlet.Hello</servlet-class>   <!-- 包名+类名 -->
        <load-on-startup>0</load-on-startup>  <!-- 当小于0时，是在访问的时候创建对象 -->
    </servlet>
```

之后启动服务器，显示台显示调用了默认构造函数和init()函数。



## 虚拟目录

此前，程序的根目录一直都是**`webapps`**目录,如下 ，是`server.xml`目录下的配置：

```xml
  <Host name="localhost"  appBase="webapps"
            unpackWARs="true" autoDeploy="true">
```

其中：

+ **"localhost"：表示127.0.0.1的别名**
+ **appBase：表示"webapps"为程序的根目录**
+ **unpackWars：表示是否给自动解包**
   <img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190941923.png" alt="image-20231128202511663" style="zoom: 33%;" />
   之后查看webapps：
   <img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190941051.png" alt="image-20231128203055329" style="zoom:50%;" />
   **发现unpack已经自动解压完成。**
   + **jar：Java archive**
   + **war：Web archive**

这时候设置虚拟目录：

首先，把已有的demo目录复制到G盘下：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190941100.png" alt="image-20231128203837832" style="zoom:50%;" />

随后对`server.xml`进行添加：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190941839.png" alt="image-20231128204315871" style="zoom:50%;" />

其中：

+ **path：指的是访问路径，可以任意取，是hello项目的别称，设想如果同时访问不同位置下的hello项目，访问路径不能都一样。**
+ **docBase：是指定单个Web应用程序的根目录，而appbase是指定存放所有Web应用程序的目录。**

之后重启服务器，对两个位置的demo项目进行访问：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190941099.png" alt="image-20231128204521200" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190941359.png" alt="image-20231128204609626" style="zoom:50%;" />

虚拟目录创建成功。



## Servlet的生命周期

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190937092.png" alt="image-20231219093745011" style="zoom: 33%;" />

其中，步骤3，4，5，8是Servlet主要的生命周期。



# GenericServlet

如果我们要实现Servlet接口，那么需要重写它的多个方法，GenericServlet实现了Servlet接口，如下：

```java
package com.servlet;

import javax.servlet.*;
import java.io.IOException;
import java.io.PrintWriter;

//实现接口
public class GenericHello extends GenericServlet{
    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        System.out.println("GenericService begin");
        PrintWriter out = servletResponse.getWriter();
        out.println("hello GenericServlet!");
    }
}
```

修改一个web.xml文件的映射

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190947798.png" alt="image-20231219094752717" style="zoom:50%;" />

启动服务器进行访问：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190948693.png" alt="image-20231219094809656" style="zoom: 50%;" />

GenericServlet类相较于Servlet类，方便了许多，但是都要实现**`service()`**方法。



# HttpServlet:fire:

`HttpServlet`是第三类Servlet，它继承了GenericServlet类。

```java
package com.servlet;

import javax.servlet.*;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

//实现接口
public class HelloHttp extends HttpServlet{
    @Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        PrintWriter out = resp.getWriter();
        out.println("Hello doGet()");
        System.out.println("doGet()");
    }
    
    @Override
    public void doPost(HttpServletRequest req,HttpServletResponse resp) throws ServletException,IOException{
        PrintWriter out = resp.getWriter();
        out.println("Hello doPost()");
        System.out.println("doPost()");
    }
}
```

没有强制重写service()方法，其中，doGet()方法是service()的重载方法，但是doGet()只能处理Get请求，而service()可以处理Get，Post等请求。

## doGet()和doPost()

doGet()和doPost()有什么区别呢，启动上面的程序，在浏览器查看：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190950393.png" alt="image-20231219095048358" style="zoom: 67%;" />

可见从浏览器上通过地址访问是Get请求。那么Post请求呢？

现在，添加一个html文件，其中添加一个指向HttpServlet的超链接，指间接访问HttpServlet

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190955341.png" alt="image-20231219095500290" style="zoom:50%;" />

不过通过超链接访问也是doGet()方法，好了不卖关子了，**post方法的调用需要指定，默认方法是get。**

添加一个提交按钮和提交内容：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<form action="Http">
    提交内容<input type = "text" name = "content">
    <input type = "submit">
</form>
</body>
</html>
```



<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190958773.png" alt="image-20231219095845736" style="zoom:50%;" />

点击提交

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190959793.png" alt="image-20231219095900756" style="zoom:50%;" />

还是get方法，注意此时，我们提交的数据和地址栏一起传输。现在指定方法：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <form action="/demo/httpserve" method = "post">
        提交内容<input type = "text" name = "content">
        <input type = "submit">
    </form>
</body>
</html>
```

之后启动服务器

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312191002207.png" alt="image-20231219100204169" style="zoom:50%;" />

这时，终于调用了post方法，不过注意地址栏内，没有伴随着提交的数据，而是在Http请求体中传送的。

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312191003056.png" alt="image-20231219100327021" style="zoom:50%;" />

接下来是对两者区别的总结：

+ **表单Get请求和Post请求的区别**

   + **数据发送方式不同**
      + **Get请求的数据是通过URL进行发送的，Post请求的数据包含在请求体当中进行发送**
         **的**

   + **传送数据大小不同**
      + **Get传输的数据有大小限制，因为Get是通过URL提交数据，浏览器对URL的长度**
         **的是有限制的。Post没有限制提交的数据**

   + **安全性不同**
      + **因为Get请求数据明文出现在URL中，而且GET请求的数据会被浏览器缓存起来**
         **可以查到历史浏览记录，数据不太安全。而Pos数据在请求体中，安全性更高些**

   + **响应速度**
      + **Get>Post。get请求服务器立即处理请求，而post请求可能形成一个队列请求**

***



# web.xml扩展

## 更改mapping

一直以来，都是一个url对应一个Servlet，但是一个Servlet可以有多个url：

```xml
<servlet-mapping>
        <servlet-name>h</servlet-name>  <!-- h指HelloHttp类 -->
        <url-pattern>/httpserve</url-pattern>
        <url-pattern>/http2</url-pattern>
        <url-pattern>/http3</url-pattern>
    </servlet-mapping>
```

<img src="../../%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/md/pic/image-20231129175420699.png" alt="image-20231129175420699" style="zoom:50%;" />

此时，http2也可以访问。不过，一个url只能对应一个Servlet

此外，还可以使用不存在的目录名

```xml
<servlet-mapping>
        <servlet-name>h</servlet-name>  <!-- h指HelloHttp类 -->
        <url-pattern>/h1/h2</url-pattern> 
    </servlet-mapping>
```

<img src="../../%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/md/pic/image-20231129175631639.png" alt="image-20231129175631639" style="zoom: 50%;" />

也可以使用**通配符**访问：

```xml
<servlet-mapping>
        <servlet-name>h</servlet-name>  <!-- h指HelloHttp类 -->
        <url-pattern>/h1/*</url-pattern>
    </servlet-mapping>
```

<img src="../../%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/md/pic/image-20231129175803120.png" alt="image-20231129175803120" style="zoom: 50%;" />

```xml
<servlet-mapping>
        <servlet-name>h</servlet-name>
        <url-pattern>/*</url-pattern>
    	<url-pattern>/</url-pattern>
    </servlet-mapping>
```

**注意，当路径为`/`时，只能阻拦静态资源，不能阻拦动态网页如jsp，但是为`/*`时，任何资源都可以访问**

### 添加后缀

mapping中可以添加后缀，如下：

```xml
<servlet-mapping>
        <servlet-name>h</servlet-name>  <!-- h指HelloHttp类 -->
        <url-pattern>/httpserve.do</url-pattern>
    </servlet-mapping>
```

<img src="../../%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/md/pic/image-20231129201250512.png" alt="image-20231129201250512" style="zoom: 50%;" />

后缀名可以任取

也可以这样：

```xml
<servlet-mapping>
        <servlet-name>h</servlet-name>  <!-- h指HelloHttp类 -->
        <url-pattern>*.do</url-pattern>  <!-- 注意不能带'/' -->
    </servlet-mapping>
```



<img src="../../%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/md/pic/image-20231129201337295.png" alt="image-20231129201337295" style="zoom:50%;" />

但是要注意不能带`/`。

总结：

<img src="../../%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/md/pic/image-20231129202024746.png" alt="image-20231129202024746" style="zoom:50%;" />

<img src="../../%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/md/pic/image-20231129202104507.png" alt="image-20231129202104507" style="zoom:50%;" />

例题：

<img src="../../%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/md/pic/a1ae3481ee98d8e3201b96ae772372e.jpg" alt="a1ae3481ee98d8e3201b96ae772372e" style="zoom:50%;" />

总结：**精确匹配>  /abc/*  >  /*  >  /*.do**



##  init-param

web.xml中，servlet还可以有很多的参数，比如`init-param`，它用来配置servlet的参数

```xml
<servlet>
        <servlet-name>h</servlet-name>
        <servlet-class>com.servlet.HelloHttp</servlet-class>
        <load-on-startup>0</load-on-startup> 
        
        <init-param>
            <param-name>para</param-name>   <!-- 参数名 -->
            <param-value>99</param-value>   <!-- 参数值 -->
        </init-param>
    </servlet>

    <servlet-mapping>
        <servlet-name>h</servlet-name>

        <url-pattern>/serve1</url-pattern>
    </servlet-mapping>
```

那么如何获得参数呢？

第一种，通过参数名：

```java
@Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String s = this.getInitParameter("para");  //通过参数名
        System.out.println(s);
    }
```

<img src="../../%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/md/pic/image-20231129210011916.png" alt="image-20231129210011916" style="zoom:50%;" />

第二种，通过枚举(map):

```java
public class HelloHttp extends HttpServlet{
    @Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        Enumeration<String> names = this.getInitParameterNames();

        while(names.hasMoreElements()){
            String name = names.nextElement();   //获得参数名
            System.out.println(name+" = "+this.getInitParameter(name));
        }
    }
```

结果如下：

![image-20231129210638319](../../%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/md/pic/image-20231129210638319.png)

**最终都要通过参数名去访问参数值。**
