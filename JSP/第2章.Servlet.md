<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [什么是servlet？](#%E4%BB%80%E4%B9%88%E6%98%AFservlet)
  - [类图：](#%E7%B1%BB%E5%9B%BE)
    - [实例：](#%E5%AE%9E%E4%BE%8B)
      - [配置WEB-INF:](#%E9%85%8D%E7%BD%AEweb-inf)
      - [实现Servlet接口：](#%E5%AE%9E%E7%8E%B0servlet%E6%8E%A5%E5%8F%A3)
      - [配置web.xml](#%E9%85%8D%E7%BD%AEwebxml)
      - [运行](#%E8%BF%90%E8%A1%8C)
      - [浏览器运行：](#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C)
      - [默认构造函数的调用](#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8)
  - [虚拟目录](#%E8%99%9A%E6%8B%9F%E7%9B%AE%E5%BD%95)
  - [Servlet的生命周期](#servlet%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)
- [GenericServlet](#genericservlet)
- [HttpServlet:fire:](#httpservletfire)
  - [doGet()和doPost()](#doget%E5%92%8Cdopost)
- [web.xml扩展](#webxml%E6%89%A9%E5%B1%95)
  - [更改mapping](#%E6%9B%B4%E6%94%B9mapping)
    - [添加后缀](#%E6%B7%BB%E5%8A%A0%E5%90%8E%E7%BC%80)
  - [init-param](#init-param)
- [请求处理：(request)](#%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86request)
  - [常见请求头状态码：](#%E5%B8%B8%E8%A7%81%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%8A%B6%E6%80%81%E7%A0%81)
  - [获取请求头信息](#%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%BF%A1%E6%81%AF)
  - [获取请求数据：](#%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE)
    - [doPost()乱码](#dopost%E4%B9%B1%E7%A0%81)
  - [乱码问题](#%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98)
    - [Post请求：](#post%E8%AF%B7%E6%B1%82)
    - [get请求：](#get%E8%AF%B7%E6%B1%82)
    - [响应](#%E5%93%8D%E5%BA%94)
  - [request获取其它信息：](#request%E8%8E%B7%E5%8F%96%E5%85%B6%E5%AE%83%E4%BF%A1%E6%81%AF)
  - [请求转发](#%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91)
- [响应处理(response)](#%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86response)
  - [重定向](#%E9%87%8D%E5%AE%9A%E5%90%91)
    - [相对路径和绝对路径](#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84)
  - [重定向和请求转发的区别：](#%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB)
- [会话跟踪](#%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 什么是servlet？

**servlet = server + applet，意为服务器端的小程序**

**servlet是一种 Java class**，它运行在Java EE的web容器内，**当Web容器接收到对他的request时，自动创建Servlet对象，并自动调用它的相应方法。本质上是一个Java定义的一个类。**



## 类图：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190939095.jpg" alt="3b0ddf3b360cff4ea4102b721e479a0" style="zoom: 33%;" />

Java提供了Servlet接口，在此基础上通过GenericServlet类实现，而HttpServlet类继承了GenericServlet类。



### 实例：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940800.png" alt="image-20231128092117104" style="zoom:50%;" />

所有app项目都要创建在webaaps下面，现在新建demo项目。

创建一个简单html文件：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940780.png" alt="image-20231128092437252" style="zoom:50%;" />

**此时，启动本地Tomcat服务器，在浏览器端输入：**

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940919.png" alt="image-20231128092821034" style="zoom:50%;" />

其中：

+ 127.0.0.1：表示本机IP地址
+ 8080：表示端口
+ **可见开启服务器后，会直接定位到webapps目录下，随后我们进入了demo项目，选择访问hello.html文件**



#### 配置WEB-INF:

之后，**在demo项目下面创建，WEB-INF文件夹，顾名思义，WEB-INF表示web的信息，在它的下面创建：**

+ **classes文件夹：项目运行后，会生成许多.class字节码，全部存储在其中**
+ **lib文件夹：存放该项目运用到的依赖库**
+ **web.xml：web.xml是Java Web应用程序的配置文件，用于配置和定义Web应用程序的各种组件、行为和属性。**



#### 实现Servlet接口：

**在classes可以存放Java源代码和class字节码**，在其中创建Hello.java文件。

```java
package com.servlet;

import javax.servlet.*;
import java.io.IOException;
//实现接口
public class Hello implements Servlet{

    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        
    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
			//提供服务，Servlet主要服务写在此方法中
        System.out.println("Service");
    }

    @Override
    public String getServletInfo() {
        return null;
    }

    @Override
    public void destroy() {

    }
}
```

之后运行：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940130.png" alt="image-20231128095237270" style="zoom:50%;" />

+ **javac：表示进行编译**
+ **-d：表示字节码存放指定位置**
+ **.：表示当前文件夹**
+ **hello.java：表示编译目标**

编译成功：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940360.png" alt="image-20231128095911354" style="zoom:67%;" />

#### 配置web.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
  version="4.0"
  metadata-complete="true">

  <display-name>Welcome to Tomcat</display-name>
  <description>
     Welcome to Tomcat
  </description>

	<servlet>
		<servlet-name>h</servlet-name>   <!-- 名字随便取 -->
		<servlet-class>com.servlet.Hello</servlet-class>   <!-- 包名+类名 -->
	</servlet>
	
	<servlet-mapping>
		<servlet-name>h</servlet-name> <!-- 与上面的servlet-name 一样 -->
		<url-pattern>/a</url-pattern>   <!-- 随便取，但是"/"不能少 -->
	</servlet-mapping>

</web-app>

```

+ `<servlet>`元素用于配置Servlet
   其中：
   + **`servlet-name`是为Servlet指定一个唯一的名称，用于在其他配置元素中引用该Servlet。它是一个字符串值，可以自定义，但必须是唯一的。在同一个web.xml文件中，不同的Servlet需要有不同的名称。**
   + **`servlet-class`指定了Servlet的类名，即实现Servlet接口的Java类。它是一个字符串值，需要指定完整的类名，包括包名。例如：`com.example.MyServlet`。当Web容器启动时，会根据这个类名来实例化和加载相应的Servlet类。**

+ **`<servlet-mapping>`元素用于将Servlet映射到URL模式（URL pattern），以指定哪些URL请求应该由哪个Servlet处理。`<servlet-mapping>`元素与`servlet-name`和`<servlet>`元素中的`servlet-name`属性相关联。**

   **其中：**

   + **`servlet-name`属性：`<servlet-name>`定义了Servlet的名称，必须与`<servlet>`元素中的`servlet-name`保持一致。它用于标识Servlet，并在其他配置元素中引用Servlet。**
   + **`<servlet-mapping>`元素：`<servlet-mapping>`用于指定Servlet的映射关系，即将Servlet映射到URL模式。它包含一个或多个`<url-pattern>`元素，每个`<url-pattern>`定义了一个URL模式。**
   + **映射关系：通过将`servlet-name`和`<url-pattern>`进行匹配，建立Servlet与URL模式之间的映射关系。当用户请求一个URL时，Web容器会根据这些映射关系，找到对应的Servlet来处理该请求。**



#### 运行

此时开启Tomcat服务器，并在浏览器访问

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940850.png" alt="image-20231128133311307" style="zoom:50%;" />

注意取名规则：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940963.png" alt="image-20231128133705134" style="zoom: 50%;" />



#### 浏览器运行：

上面的运行是在本地运行，接下来要实现响应，即服务器**respond**浏览器，只需要更改`service`方法。

```java
@Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        //提供服务，Servlet主要服务写在此方法中
        //System.out.println("Service");
        PrintWriter out = servletResponse.getWriter();
        out.println("hello web!");
    }
```

浏览器查看：

![image-20231128134722967](https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940611.png)

**在response中，我们只需要编辑响应体，不需要编辑响应头。**



#### 默认构造函数的调用

添加默认构造函数，对init()和service()进行修改：

```java
package com.servlet;

import javax.servlet.*;
import java.io.IOException;
import java.io.PrintWriter;

//实现接口
public class Hello implements Servlet{

    //默认构造函数
    public Hello(){
        System.out.println("create()");
    }

    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        System.out.println("init()");
    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        //提供服务，Servlet主要服务写在此方法中
        //System.out.println("Service");
        System.out.println("Service begin");
        PrintWriter out = servletResponse.getWriter();
        out.println("hello web!");
    }

    @Override
    public String getServletInfo() {
        return null;
    }

    @Override
    public void destroy() {

    }
}
```

运行服务器，在浏览器进行访问，并且**刷新进行二次访问**，控制台结果如下：

![image-20231128193939807](https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190940361.png)

可知，**在对服务器进行访问时，服务器会自动调用Servlet的默认构造函数，然后调用init()函数，这两个函数只调用一次，因为第一次调用后虚拟机中存在Servlet的字节码，所以不用再创造对象，而每次访问服务器，都会调用service函数**



如果要**在服务器开启时创建Servlet对象**，只需对web.xml文件进行修改：

```xml
<servlet>
        <servlet-name>h</servlet-name>   <!-- 名字随便取 -->
        <servlet-class>com.servlet.Hello</servlet-class>   <!-- 包名+类名 -->
        <load-on-startup>0</load-on-startup>  <!-- 当小于0时，是在访问的时候创建对象 -->
    </servlet>
```

之后启动服务器，显示台显示调用了默认构造函数和init()函数。



## 虚拟目录

此前，程序的根目录一直都是**`webapps`**目录,如下 ，是`server.xml`目录下的配置：

```xml
  <Host name="localhost"  appBase="webapps"
            unpackWARs="true" autoDeploy="true">
```

其中：

+ **"localhost"：表示127.0.0.1的别名**
+ **appBase：表示"webapps"为程序的根目录**
+ **unpackWars：表示是否给自动解包**
   <img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190941923.png" alt="image-20231128202511663" style="zoom: 33%;" />
   之后查看webapps：
   <img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190941051.png" alt="image-20231128203055329" style="zoom:50%;" />
   **发现unpack已经自动解压完成。**
   + **jar：Java archive**
   + **war：Web archive**

这时候设置虚拟目录：

首先，把已有的demo目录复制到G盘下：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190941100.png" alt="image-20231128203837832" style="zoom:50%;" />

随后对`server.xml`进行添加：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190941839.png" alt="image-20231128204315871" style="zoom:50%;" />

其中：

+ **path：指的是访问路径，可以任意取，是hello项目的别称，设想如果同时访问不同位置下的hello项目，访问路径不能都一样。**
+ **docBase：是指定单个Web应用程序的根目录，而appbase是指定存放所有Web应用程序的目录。**

之后重启服务器，对两个位置的demo项目进行访问：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190941099.png" alt="image-20231128204521200" style="zoom: 50%;" />

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190941359.png" alt="image-20231128204609626" style="zoom:50%;" />

虚拟目录创建成功。



## Servlet的生命周期

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190937092.png" alt="image-20231219093745011" style="zoom: 33%;" />

其中，步骤3，4，5，8是Servlet主要的生命周期。



# GenericServlet

如果我们要实现Servlet接口，那么需要重写它的多个方法，GenericServlet实现了Servlet接口，如下：

```java
package com.servlet;

import javax.servlet.*;
import java.io.IOException;
import java.io.PrintWriter;

//实现接口
public class GenericHello extends GenericServlet{
    @Override
    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
        System.out.println("GenericService begin");
        PrintWriter out = servletResponse.getWriter();
        out.println("hello GenericServlet!");
    }
}
```

修改一个web.xml文件的映射

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190947798.png" alt="image-20231219094752717" style="zoom:50%;" />

启动服务器进行访问：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190948693.png" alt="image-20231219094809656" style="zoom: 50%;" />

GenericServlet类相较于Servlet类，方便了许多，但是都要实现**`service()`**方法。



# HttpServlet:fire:

`HttpServlet`是第三类Servlet，它继承了GenericServlet类。

```java
package com.servlet;

import javax.servlet.*;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

//实现接口
public class HelloHttp extends HttpServlet{
    @Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        PrintWriter out = resp.getWriter();
        out.println("Hello doGet()");
        System.out.println("doGet()");
    }
    
    @Override
    public void doPost(HttpServletRequest req,HttpServletResponse resp) throws ServletException,IOException{
        PrintWriter out = resp.getWriter();
        out.println("Hello doPost()");
        System.out.println("doPost()");
    }
}
```

没有强制重写service()方法，其中，doGet()方法是service()的重载方法，但是doGet()只能处理Get请求，而service()可以处理Get，Post等请求。

## doGet()和doPost()

doGet()和doPost()有什么区别呢，启动上面的程序，在浏览器查看：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190950393.png" alt="image-20231219095048358" style="zoom: 67%;" />

可见从浏览器上通过地址访问是Get请求。那么Post请求呢？

现在，添加一个html文件，其中添加一个指向HttpServlet的超链接，指间接访问HttpServlet

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190955341.png" alt="image-20231219095500290" style="zoom:50%;" />

不过通过超链接访问也是doGet()方法，好了不卖关子了，**post方法的调用需要指定，默认方法是get。**

添加一个提交按钮和提交内容：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<form action="Http">
    提交内容<input type = "text" name = "content">
    <input type = "submit">
</form>
</body>
</html>
```



<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190958773.png" alt="image-20231219095845736" style="zoom:50%;" />

点击提交

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312190959793.png" alt="image-20231219095900756" style="zoom:50%;" />

还是get方法，注意此时，我们提交的数据和地址栏一起传输。现在指定方法：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <form action="/demo/httpserve" method = "post">
        提交内容<input type = "text" name = "content">
        <input type = "submit">
    </form>
</body>
</html>
```

之后启动服务器

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312191002207.png" alt="image-20231219100204169" style="zoom:50%;" />

这时，终于调用了post方法，不过注意地址栏内，没有伴随着提交的数据，而是在Http请求体中传送的。

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312191003056.png" alt="image-20231219100327021" style="zoom:50%;" />

接下来是对两者区别的总结：

+ **表单Get请求和Post请求的区别**

   + **数据发送方式不同**
      + **Get请求的数据是通过URL进行发送的，Post请求的数据包含在请求体当中进行发送**
         **的**

   + **传送数据大小不同**
      + **Get传输的数据有大小限制，因为Get是通过URL提交数据，浏览器对URL的长度**
         **的是有限制的。Post没有限制提交的数据**

   + **安全性不同**
      + **因为Get请求数据明文出现在URL中，而且GET请求的数据会被浏览器缓存起来**
         **可以查到历史浏览记录，数据不太安全。而Pos数据在请求体中，安全性更高些**

   + **响应速度**
      + **Get>Post。get请求服务器立即处理请求，而post请求可能形成一个队列请求**

***



# web.xml扩展

## 更改mapping

一直以来，都是一个url对应一个Servlet，但是一个Servlet可以有多个url：

```xml
<servlet-mapping>
        <servlet-name>h</servlet-name>  <!-- h指HelloHttp类 -->
        <url-pattern>/httpserve</url-pattern>
        <url-pattern>/http2</url-pattern>
        <url-pattern>/http3</url-pattern>
    </servlet-mapping>
```

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312222315237.png" alt="image-20231222231546194" style="zoom:50%;" />

此时，http2也可以访问。不过，一个url只能对应一个Servlet

此外，还可以使用不存在的目录名

```xml
<servlet-mapping>
        <servlet-name>h</servlet-name>  <!-- h指HelloHttp类 -->
        <url-pattern>/h4/h5</url-pattern>
    </servlet-mapping>
```

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312222318028.png" alt="image-20231222231824988" style="zoom:50%;" />

也可以使用**通配符**访问：

```xml
<servlet-mapping>
        <servlet-name>h</servlet-name>  <!-- h指HelloHttp类 -->
        <url-pattern>/h1/*</url-pattern>
    </servlet-mapping>
```

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312222319858.png" alt="image-20231222231937820" style="zoom:50%;" />

```xml
<servlet-mapping>
        <servlet-name>h</servlet-name>
        <url-pattern>/*</url-pattern>
    	<url-pattern>/</url-pattern>
    </servlet-mapping>
```

**注意，当路径为`/`时，只能阻拦静态资源，不能阻拦动态网页如jsp，但是为`/*`时，任何资源都可以访问**。

何为**拦截**：不论访问哪个页面，都会返回那个页面。

### 添加后缀

mapping中可以添加后缀，如下：

```xml
<servlet-mapping>
        <servlet-name>h</servlet-name>  <!-- h指HelloHttp类 -->
        <url-pattern>/httpserve.do</url-pattern>
    </servlet-mapping>
```

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312222331646.png" alt="image-20231222233136606" style="zoom:50%;" />

后缀名可以任取

也可以这样：

```xml
<servlet-mapping>
        <servlet-name>h</servlet-name>  <!-- h指HelloHttp类 -->
        <url-pattern>*.do</url-pattern>  <!-- 注意不能带'/' -->
    </servlet-mapping>
```

但是要注意不能带`/`。

总结：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312222335714.png" alt="image-20231222233521643" style="zoom:50%;" />

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312222335061.png" alt="image-20231222233550016" style="zoom:50%;" />

例题：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312222336384.png" alt="image-20231222233628335" style="zoom:50%;" />

总结：**精确匹配>  /abc/*  >  /*  >  /*.do**



##  init-param

web.xml中，servlet还可以有很多的参数，比如`init-param`，它用来配置servlet的参数

```xml
<servlet>
        <servlet-name>h</servlet-name>
        <servlet-class>com.servlet.HelloHttp</servlet-class>
        <load-on-startup>0</load-on-startup> 
        
        <init-param>
            <param-name>para</param-name>   <!-- 参数名 -->
            <param-value>99</param-value>   <!-- 参数值 -->
        </init-param>
    </servlet>

    <servlet-mapping>
        <servlet-name>h</servlet-name>

        <url-pattern>/serve1</url-pattern>
    </servlet-mapping>
```

那么如何获得参数呢？

第一种，通过参数名：

```java
@Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String s = this.getInitParameter("para");  //通过参数名
        System.out.println(s);
    }
```



第二种，通过枚举(map):

```java
public class HelloHttp extends HttpServlet{
    @Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        Enumeration<String> names = this.getInitParameterNames();

        while(names.hasMoreElements()){
            String name = names.nextElement();   //获得参数名
            System.out.println(name+" = "+this.getInitParameter(name));
        }
    }
```

结果如下：

![image-20231222235436659](https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312222354691.png)

**最终都要通过参数名去访问参数值。**



# 请求处理：(request)

一个Http请求由三个部分构成：

+ **请求行：**
   + **请求方式：get或post**
   + **uri，统一资源标识符**
   + **协议和版本号**

+ **请求头**，一些常见请求头：
   + Accept：浏览器可接受的文件类型
   + Accept - Charset：浏览器可接受的字符集
   + Accept - Encoding：浏览器可接受的压缩编码方式
   + Cache - Control：是否网页缓存
   + Content- Length：请求消息正文的长度
   + Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面，比如通过超链接访问一个页面，refer就是超链接的来源页
   + User-Agent：浏览器类型
   + if - Modified - Since：请求资源的最后一次修改时间
+ **请求体**



## 常见请求头状态码：

+ 200：正常
+ 404：文件不存在
+ 500：异常报告，比如5/0等等
+ 304：缓存出问题
+ 302：重定向问题



## 获取请求头信息

以上面的Refer为例，假设有一个指向servlet的超链接位于一个html文件中，通过超链接访问servlet，servlet输出Refer：

```java
    public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        PrintWriter out = resp.getWriter();
        out.println(req.getHeader("Referer"));
    }
```

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312231506146.png" alt="image-20231223150623064" style="zoom:50%;" />



很明显，请求头的保存方式是一个Map：它的键是一个`keyset`，值是一个`list`，我们可以这样获取请求头信息：

```java
    public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        PrintWriter out = resp.getWriter();
        
        Enumeration<String> names = req.getHeaderNames();
        
        while(names.hasMoreElements())
        {
            String name = names.nextElement();
            System.out.println(name + " : " + req.getHeader(name));
        }
    }
```

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312231515137.png" alt="image-20231223151519083" style="zoom:50%;" />

## 获取请求数据：

如果是doGet方式，用户提交的数据是放在URL中的，如果是doPost方式，则是放在请求体中。

此时，在test.html中，有一个向servlet提交的表单:

```html
<body>
    <form action = "/demo/serve1">
        用户名<input type = "text" name = "name">
        密码<input type = "password"  name = "pwd">
        <input type = "submit">
</body>
```

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312231535200.png" alt="image-20231223153500156" style="zoom:50%;" />

想要获取表单内容：

```java
public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        PrintWriter out = resp.getWriter();

        out.println(req.getParameter("name"));
        out.println(req.getParameter("pwd"));
    }
```

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312231535279.png" alt="image-20231223153519239" style="zoom:50%;" />

和init-parameter一样，它也存储在Map中，因此可以使用`Enumeration接口`，获取参数名集合，再获取参数值。



### doPost()乱码

当把上述表单的提交方式换为doPost()，并提交中文名字时，会出现乱码情况。

![image-20231223154444646](https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312231544685.png)

这是因为html文件使用了UTF-8

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312231546606.png" alt="image-20231223154628558" style="zoom:50%;" />

而在Tomcat服务器，请求和响应的时候都使用`iso-8859-1`的编码方式，所以会乱码



## 乱码问题

### Post请求：

```java
public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        PrintWriter out = resp.getWriter();

        String userName = req.getParameter("name");
        userName = new String(userName.getBytes("iso-8859-1"),"utf-8");
        System.out.println(userName);
    }
```

![image-20231223155716562](https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312231557605.png)

此时，控制台正常输出中文。这种方法，是**先以iso-8859-1的方式解码，再以utf-8的方式编码**

或者，也可以提前先设置Tomcat的请求方式为utf-8。

```java
    @Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.setCharacterEncoding("utf-8");
        PrintWriter out = resp.getWriter();

        String userName = req.getParameter("name");
        System.out.println(userName);
    }
```



### get请求：

get请求也存在同样的问题

1. 首先可以通过提前设置Tomcat的请求方式为utf-8：

   ```java
   req.setCharacterEncoding("utf-8");
   ```

2. 修改Tomcat的server.xml的Connector标签中的编码方式：

   ```xml
   URIEncoding UTF-8
   ```




### 响应

1. 在前面的学习中，我们得到了响应的输出流，`PrintWriter`，它是字符输出流，还有一种输出流，叫做`OutputStream`，它是字节输出流。在`PrintWriter`中，有以下几种方式输出：

   ```java
   PrintWriter out = res.getWriter();
   
   out.println("hello");
   out.append("hello");
   out.write("hello");
   ```

   如果输出中文，那么会出现乱码的情况。因为此时的编码方式也是iso-8859-1。此时，解决方法有：

   1. 既然可以设置请求体的类型，那么也可以设置响应体的编码方式，不过还要设置**内容类型**，如下：

      ```java
          @Override
          public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
              resp.setContentType("text/html");  //告诉client，返回一个html文件
              resp.setCharacterEncoding("utf-8");  //告诉client，返回内容的编码方式是utf-8
              PrintWriter out = resp.getWriter();
      
              String pwd = req.getParameter("pwd");
              String userName = req.getParameter("name");
              out.println(userName);
              out.println(pwd);
          }
      ```

      <img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312231719180.png" alt="image-20231223171915279" style="zoom:50%;" />

      不过，此时会发现没有了换行，那是因为，**在html中，换行都被替换成了一个空格**。

   2. 当不指定内容类型时，返回的是`text/plain`是一个字符串，而平台的编码方式是GBK，所以使用utf-8会乱码。所以使用GBK编码，无论是什么内容类型，都不会乱码：

      ```java
          @Override
          public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
      //        resp.setContentType("text/html");    可有可无
              resp.setCharacterEncoding("GBK");
              PrintWriter out = resp.getWriter();
      
              String pwd = req.getParameter("pwd");
              String userName = req.getParameter("name");
              out.println(userName);
              out.println(pwd);
          }
      
      ```



可以将上述的两条控制代码合二为一：

```java
resp.setContentType("text/html;charset=utf-8");
```



## request获取其它信息：

+ `getRequestURL`：获得客户请求时输入的地址
+ `getRequestURI`：获得客户请求的资源
+ `getQueryString`：获得请求的字符串，只对get起作用
+ `getRemoteHost`：获得客户端的主机名，如果没有，则返回IP

```java
PrintWriter out = resp.getWriter();
out.println(req.getRequestURL());
out.println(req.getRequestURI());
out.println(req.getQueryString());
```

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312231751188.png" alt="image-20231223175142143" style="zoom:50%;" />

## 请求转发

一个web组件，将没有完成的处理交给另一个web组件继续处理。称为转发。

使用`request.getRequestDispatcher()`来进行转发，操作如下：

```java
@Override
public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    RequestDispatcher patcher = req.getRequestDispatcher("/serve2");   //不能写为/demo/serve2
    patcher.forward(req,resp);                                         //但是可以写为"serve2",表示在当前目录下   
}
```

然后让servlet2输出：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312231815704.png" alt="image-20231223181502658" style="zoom:50%;" />

注意，这里的URL仍然是servlet的访问地址。

注意，请求转发只能在同一个Web应用中进行，此例中，这个应用就是demo项目。而且转发路径不能写上项目名。

此时，servlet1的request对象和servlet2是共享的:

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312231832750.png" alt="image-20231223183204703" style="zoom:50%;" />



可以用`request.setAttribute()`存储用于在服务器端不同组件之间共享的数据，比如传入bobby和123，之后存储：

```java
@Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        PrintWriter out = resp.getWriter();
        out.println(req.getParameter("name"));
        out.println(req.getParameter("pwd"));
        req.setAttribute("new_name","mike");
        req.setAttribute("new_pwd","789");
        out.println(req.getParameter("name"));
        out.println(req.getParameter("pwd"));
        out.println(req.getAttribute("new_name"));
        out.println(req.getAttribute("new_pwd"));
    }
```

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312231857507.png" alt="image-20231223185726457" style="zoom:50%;" />

可以说，servlet1可以通过此方法添加request对象的属性，然后转发给servlet2.

注意Attribute和Parameter的区别：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312231901315.png" alt="image-20231223190123233" style="zoom:50%;" />



# 响应处理(response)

以前在网页进行文字回答，都是用字符流类型:`PrintWriter`，还有字节输出流`ServletOutputStream`，可以用来输出图片等。

输出一张图片：先在项目下放一张名为pic.png的图片文件，之后操作：

```java
    @Override
    public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletOutputStream out = resp.getOutputStream();
        String path = this.getServletContext().getRealPath("pic.png");
//        System.out.println(path);   G:\IDEA\Web_demo\out\artifacts\test1_war_exploded\pic.png
        FileInputStream fis = new FileInputStream(path);
        byte[] b = new byte[1024];
        int n ;
        while((n = fis.read(b))!=-1){
            out.write(b,0,n);
        }
    }
```

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312232255660.png" alt="image-20231223225444678" style="zoom: 33%;" />



## 重定向

不同于转发操作：

让servlet1重定向于servlet2，然后servlet输出信息

```java
@Override
public void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
           resp.sendRedirect("serve2");
}
```

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312232320206.png" alt="image-20231223232046158" style="zoom:50%;" />

**注意此时地址栏已经由serve1变成serve2**，此时，查看浏览器信息：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312232322135.png" alt="image-20231223232221089" style="zoom:50%;" />

servlet1的状态码是302，servlet2正常；再看initiator，servlet2的是servlet1。

**重定向的过程就是：客户访问servlet1，servlet1返回给客户一个URL，之后客户访问该URL，该URL再返回该客户**

不同于请求转发，重定向不规定只能指向该app目录下的零件，比如此时重定向到b站官网，它依旧可以执行：

```java
resp.sendRedirect("http://www.bilibili.com/");  //必须以http://开头
```

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312232336679.png" alt="image-20231223233608460" style="zoom:50%;" />



### 相对路径和绝对路径

+ **绝对路径 = 参考路径 + 相对路径**

+ **相对路径最终时需要转换成绝对路径执行**



在此之前理解两个**根目录**：

+ **Web服务器根目录：`servlet container root`**
+ **Web应用根目录：`servlet context root`**



在上面的例子中：

我们用：

```java
resp.sendRedirect("serve2");
```

访问servlet2，这里采用了相对路径，我们原先的访问路径是`http://localhost:8080/demo/serve1`，此时servlet2也在demo目录下，所以可以访问。不过如果更改servlet1的mapping为/test/serve1，就不能再通过"serve2"访问了。此时，会显示如下：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312240048127.png" alt="image-20231224004840076" style="zoom:50%;" />

很明显，servlet2的mapping不包含test，servlet2也不在test目录下，此时只能更改servlet2的mapping为`/test/serve2`或者使用servlet2的绝对路径。

那么应该如何写servlet2的绝对路径呢？

```java
resp.sendRedirect("http://localhost:8080/demo/serve2");
resp.sendRedirect("/demo/serve2");
```

这是两种servlet2的绝对路径的写法，看第二种写法，就用到了**Web服务器根目录**的知识。



现在来复盘之前用到路径的地方，重定向就不说了：

1. 请求转发

   在请求转发中，servlet2只能是应用中的零件，所以"/"只能指向**Web应用根目录**。所以：

   ```java
   req.getRequestDispatcher("/serve2");
   ```

   所以此时的路径就是`/demo/serve2`，因此不能使用

   ```java
   req.getRequestDispatcher("/demo/serve2");
   ```

   不然路径就是`/demo/demo/serve2`

   <img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312240114247.png" alt="image-20231224011455194" style="zoom:50%;" />

   当然，使用相对路径也可以访问：

   ```java
   req.getRequestDispatcher("serve2");
   ```

   前提是servlet1的访问路径是"`/serve1`"而不是"`/test/serve1`"，否则：

   <img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312240121262.png" alt="image-20231224012148210" style="zoom:50%;" />

2. mapping中，其根目录是Web应用根目录，不能使用相对路径

3. 在html中，其根目录是Web服务器根目录，如果有一个表单要提交，采用根目录可以这样写：

   ```java
   <form action = "/demo/serve1" method="get">
   ```

   也可以使用相对路径：

   ```java
   <form action = "serve1" method="get">
   ```



## 重定向和请求转发的区别：

<img src="https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202312242256955.png" alt="image-20231224225607855" style="zoom:50%;" />



#  会话跟踪

假定有一个登录界面（Login），输入用户名和密码，如果正确，那么登录成功，界面显式名字（Main）；如果不成功，那就返回登录界面。（MainProcess）

```java
//Login.java
package com.servlet;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

public class Login extends HttpServlet {
    @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
       response.setContentType("text/html;charset=utf-8");
       PrintWriter out = response.getWriter();
       out.print("<form action = LoginProcess>");
       out.print("name<input type = \"text\" name = n>");
       out.print("password<input type = \"password\"  name = p>");
       out.print("<input type = \"submit\">");
       out.print("</form>");
    }

    @Override public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException{
        doGet(request,response);
    }
}
```

```java
//LoginProcess.java
package com.servlet;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

public class LoginProcess extends HttpServlet {
    @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
        response.setContentType("text/html;charset=utf-8");
        String name = request.getParameter("n");
        String password = request.getParameter("p");
        if(name.equals("bobby")&&password.equals("123")){
            response.sendRedirect("Main");
        }
        else
            response.sendRedirect("Login");
    }

    @Override public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException{
        doGet(request,response);
    }
}
```

```java
//Main.java
package com.servlet;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

public class Main extends HttpServlet {
    @Override public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
        response.setContentType("text/html;charset=utf-8");
        PrintWriter out = response.getWriter();
        out.print("welcome!");
    }

    @Override public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException{
        doGet(request,response);
    }
}
```

此时，只要用户名为bobby，密码为123，就可以登录到Main界面。

此时，如何让Main界面，输出`welcome bobby`呢？注意，不同于请求转发，两个servlet不共用一个request和response。

这时，需要通过重定向转发出去：

```java
response.sendRedirect("Main"+"?name="+name);
```

之后，到Main中去接收并写出：

![image-20240103235640241](https://cdn.jsdelivr.net/gh/firmiyao/Picture@main/img/202401032358271.png)

这时，会通过url一并转发。但是，如果想通过此方式转发“张三”这个名字，会出现乱码。

```java
name= URLEncoder.encode("张三","utf-8");
response.sendRedirect("Main"+"?name="+name);
```

这时，需要转换编码方式，如上。或者，以utf-8的方式读取，再以iso-8859-1的方式转发：

```java
name=new String("张三".getBytes("utf-8"),"iso-8859-1");
response.sendRedirect("Main"+"?name="+name);
```
